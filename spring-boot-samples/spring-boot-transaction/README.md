### spring transaction

[mysql事务与spring事务](https://juejin.cn/post/6989900968833843231)

#### @Transactional声明式事务

```
@Transactional 注解，是使用 AOP 实现的，本质就是在目标方法执行前后进行拦截。
在目标方法执行前加入或创建一个事务，在执行方法执行后，根据实际情况选择提交或是回滚事务。

当 Spring 遇到该注解时，会自动从数据库连接池中获取 connection，并开启事务然后绑定到
ThreadLocal 上，对于@Transactional注解包裹的整个方法都是使用同一个connection连接。
如果方法中出现了耗时的操作，就会导致长事务问题
长事务会引发哪些问题：
数据库连接池被占满，应用无法获取连接资源；
容易引发数据库死锁；
数据库回滚时间长；
在主从架构中会导致主从延时变大。

优缺点分析：
优点 ：使用很简单，可以自动帮我们进行事务的开启、提交以及回滚等操作。
缺点 ：就是事务的颗粒度是整个方法，无法进行精细化控制。
```

#### TransactionTemplate编程式事务

``` 
spring项目中可以使用TransactionTemplate类的对象API,开发者在代码中手动的管理事务的开启、提交、回滚等操作。

```

### mysql 事务
数据库的多事务并发问题，为了解决多事务并发问题，数据库设计了事务隔离机制、锁机制、MVCC多版本并发控制隔离机制，用一整套机制来解决多事务并发问题。
#### 事务特性
``` 
原子性(Atomicity) ：事务是一个原子操作单元,其对数据的修改,要么全都执行,要么全都不执行。
一致性(Consistent) ：在事务开始和完成时,数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改,以保持数据的完整性。
隔离性(Isolation) ：数据库系统提供一定的隔离机制,保证事务在不受外部并发操作影响的”独立“环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。
持久性(Durable) ：事务完成之后,它对于数据的修改是永久性的,即使出现系统故障也能够保持。
```

#### 事务隔离级别
```
在高并发的情况下，要完全保证其ACID特性是非常困难的，除非把所有的事务串行化执行，但带来的负面的影响将是性能大打折扣。
数据库中设计了四种隔离级别，供用户基于业务进行选择: read-uncommitted,read-committed,repeatable-read,serializable.
Oracle中默认级别是 Read committed
Mysql 中默认级别 Repeatable read
查看mysql 的默认隔离级别
SELECT @@tx_isolation
#设置为读未提交
set tx_isolation='read-uncommitted'; 

```
#### 并发事务处理带来的问题
``` 
更新丢失(Lost Update)或脏写: 并发更新最后的更新覆盖了由其他事务所做的更新
脏读（Dirty Reads）: 事务A读取到了事务B已经修改但尚未提交的数据
不可重读（Non-Repeatable Reads: 事务A内部的相同查询语句在不同时刻读出的结果不一致(事务B在期间修改了数据)，不符合隔离性
幻读（Phantom Reads）：事务A读取到了事务B提交的新增数据，不符合隔离性
```
