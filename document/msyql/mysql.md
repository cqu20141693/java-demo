- [mysql](#mysql)
  - [mysql 查询流程？](#mysql-查询流程)
  - [mysql 存储引擎的区别？](#mysql-存储引擎的区别)
  - [索引是什么，索引的特性](#索引是什么索引的特性)
    - [数据结构分类](#数据结构分类)
    - [逻辑分类](#逻辑分类)
    - [根据叶子节点的内容](#根据叶子节点的内容)
    - [ID自增主键的优势？为什么用B+树？](#id自增主键的优势为什么用b树)
    - [索引特点？](#索引特点)
  - [事务的特性，事务隔离级别以及解决的问题](#事务的特性事务隔离级别以及解决的问题)
  - [事务的隔离级别如何实现](#事务的隔离级别如何实现)
  - [mysql 主从复制和集群原理](#mysql-主从复制和集群原理)
  - [explain 分析优化sql](#explain-分析优化sql)
  - [锁了解吗](#锁了解吗)
    - [锁的粒度](#锁的粒度)
    - [锁的特性](#锁的特性)
    - [MVCC 可重复读](#mvcc-可重复读)
    - [解决幻读](#解决幻读)
  - [mysql 大表联合查询优化？](#mysql-大表联合查询优化)
  - [优化经验](#优化经验)
    - [命令时序表](#命令时序表)
  - [mysql 优化](#mysql-优化)
    - [索引优化](#索引优化)
    - [sql 优化](#sql-优化)
    - [读写分离](#读写分离)
    - [分库分表](#分库分表)
  
## mysql
### mysql 查询流程？


### mysql 存储引擎的区别？
```
MYISAM
不支持事务
不支持行锁
Innodb

```
### 索引是什么，索引的特性
####  数据结构分类
```
全局索引(FULLTEXT)：全局索引，目前只有 MyISAM 引擎支持全局索引，
它的出现是为了解决针对文本的模糊查询效率较低的问题，并且只限于 CHAR、VARCHAR 和 TEXT 列。

哈希索引(HASH)：哈希索引是 MySQL 中用到的唯一 key-value 键值对的数据结构，很适合作为索引。
HASH 索引具有一次定位的好处，不需要像树那样逐个节点查找，，哈希表这种结构适用于只有等值查询的场景，
对于范围查找，HASH 索引的性能就会很低。默认情况下，MEMORY 存储引擎使用 HASH 索引，但也支持 BTREE 索引。

B-Tree 索引：B 就是 Balance 的意思，BTree 是一种平衡树，它有很多变种，
最常见的就是 B+ Tree，它被 MySQL 广泛使用。

R-Tree 索引：R-Tree 在 MySQL 很少使用，仅支持 geometry 数据类型，支持该类型的存储引擎只有MyISAM、BDb、InnoDb、NDb、Archive几种，
相对于 B-Tree 来说，R-Tree 的优势在于范围查找。
```
#### 逻辑分类
```
普通索引：普通索引是最基础的索引类型，它没有任何限制 。
唯一索引：唯一索引列的值必须唯一，允许有空值，如果是组合索引，则列值的组合必须唯一
主键索引：是一种特殊的索引，一个表只能有一个主键，不允许有空值。
组合索引：指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循最左前缀原则，
全文索引：主要用来查找文本中的关键字，而不是直接与索引中的值相比较，目前只有 char、varchar，text 列上可以创建全文索引，
```
#### 根据叶子节点的内容
```
索引类型分为主键索引和非主键索引。主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）。
非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。

基于非主键索引的查询需要多扫描一棵索引树,称之为回表查询。因此，我们在应用中应该尽量使用主键查询。
```
#### ID自增主键的优势？为什么用B+树？
自增ID优势
``` 
1. 主键是一颗B+树，在进行插入数据和删除数据的时候，都需要维护数据的有序性，如果不是自增主键，则每次需要动态的维护B+树的叶子节点
2. ID主键是整形，其他的二级索引的叶子节点数据为主键值，这样可以减少索引数据大小。

```
B+,二叉树，B树
``` 
二叉树搜索性能很高，但是父节点和子节点通过指针连接，内存不连续，所以导致每一层的数据独立，当查询数据的时候会根据树的深度递增。

B+是多叉树，InnoDB引擎中，适配系统页缓存4K,平均索引长度10字节，可以有400多个兄弟节点，所以对于上亿的数据集，也最多三层，
能够很好地配合磁盘的读写特性，减少单次查询的磁盘访问次数。
B+树将数据存储在叶子节点，并且节点间通过链表相连，适合进行范围查询，对于关系型联表查询范围访问友好。
B树：中间节点也会存储数据，相较B+树磁盘IO较弱，但是其最好的时间复杂度O(1),并且Key,data聚合一起方便文档聚合。

```

#### 索引特点？
```
覆盖索引：查询数据直接在索引的数据中
最左前缀原则：联合索引，字符串左匹配
索引下推优化： 当索引存在where条件中时，索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。
```
### 事务的特性，事务隔离级别以及解决的问题
```
1. 事务的特性：原子性、一致性、隔离性、持久性
2、多事务同时执行的时候，可能会出现的问题：脏读、不可重复读、幻读
3、事务隔离级别：读未提交、读提交、可重复读、串行化
4、不同事务隔离级别的区别：
	读未提交：一个事务还未提交，它所做的变更就可以被别的事务看到
	读提交：一个事务提交之后，它所做的变更才可以被别的事务看到
	可重复读：一个事务执行过程中看到的数据是一致的。未提交的更改对其他事务是不可见的
	串行化：对应一个记录会加读写锁，出现冲突的时候，后访问的事务必须等前一个事务执行完成才能继续执行
```
### 事务的隔离级别如何实现
[ACID 原理](https://mp.weixin.qq.com/s/zXWWsHh6UB66dyINOCV1kQ)
```
MVCC:多版本并发控制。

原理提炼总结：使用版本链+Read View

详解：
版本链：同一行数据可能有多个版本

innodb数据表每行数据记录会有几个隐藏字段，row_id，事务ID，回滚指针。


总之，MYSQL的隔离性便是由MVCC+锁来保证，各个隔离级别实现原理我做了一下归纳总结：

隔离级别原理及解决问题分析：

读未提交：原理：直接读取数据，不能解决任何并发问题

读已提交：读操作不加锁，写操作加排他锁，解决了脏读。原理：利用MVCC实现，每一句语句执行前都会生成Read View（一致性视图）

可重复读：MVCC实现，只有事务开始时会创建Read View，之后事务里的其他查询都用这个Read View。解决了脏读、不可重复读，快照读（普通查询，读取历史数据）使用MVCC解决了幻读，当前读（读取最新提交数据）通过间隙锁解决幻读（lock in share mode、for update、update、detete、insert），间隙锁在可重复读下才生效。（默认隔离级别）

可串行化：原理：使用锁，读加共享锁，写加排他锁，串行执行


总结：读已提交和可重复读实现原理就是MVCC Read View不同的生成时机。可重复读只在事务开始时生成一个Read View，之后都用的这个；读已提交每次执行前都会生成Read View


```
### mysql 主从复制和集群原理
[集群](https://juejin.cn/post/6991709707534598180)
```
一主一从/多从：
双主：
双主多从:

主从异步复制（默认）： slave 节点会与主节点建立TCP连接，主节点会开启dump线程将binlog发送到slave,slave 将日志记录到relay 日志中，slave会启动另一个SQL线程重放日志复制数据
主从同步复制：
主从半同步复制： 半同步复制机制是一种介于异步复制和全同步复制之前的机制。主库在执行完客户端提交的事务后，并不是立即返回客户端响应，而是等待至少一个从库接收并写到relay log中，才会返回给客户端。MySQL在等待确认时，默认会等10秒，如果超过10秒没有收到ack，就会降级成为异步复制。

```

### [explain 分析优化sql](https://segmentfault.com/a/1190000023565685)
1. select_type
2. table
3. type
```
type扫描方式由快到慢
system > const > eq_ref > ref > range > index > ALL

system：系统表，少量数据，往往不需要进行磁盘IO
const：常量连接
eq_ref：主键索引(primary key)或者非空唯一索引(unique not null)等值扫描
ref：非主键非唯一索引等值扫描
range：范围扫描
index：索引树扫描
ALL：全表扫描(full table scan)


```
4. possible_keys
5. key
6. key_len
7. ref
8. rows
9.  filtered
10. extra

### 锁了解吗
```
锁的分类：
按锁的功能特性：共享和排他
按锁的粒度：表锁和行锁

```
#### 锁的粒度
1. 表锁
```
意向锁：意向排他锁，意向共享锁

```
2. 行锁
```
记录锁，间隙锁，临键锁
```
   
#### 锁的特性
1. 共享锁，S锁
```
当多个读请求的时候，可以并行的加锁，有利于并发
```
2. 排他锁，X锁
```
当排他锁，当添加X锁后，不能并行的加S锁和X锁
```
#### MVCC 可重复读
```

```
#### 解决幻读
1. 记录锁，间隙锁，临键锁
```
在mvcc多版本读取快照视图的支持下，完成了可重复读；
通过添加临键锁，不能进行插入操作，解决幻读
```

### mysql 大表联合查询优化？
```
主要的性能瓶颈是 count 和联合
方案一：
mysql实现是根据业务表查询count
对业务表的连表查询建立索引

方案二： 
将多表数据同步到es
通过es的高性能查询
```

### 优化经验
#### 命令时序表
```
使用mysql做时序查询表，当时使用时间作为索引，时间索引查询
```

### mysql 优化
#### 索引优化
#### sql 优化
#### 读写分离
#### 分库分表