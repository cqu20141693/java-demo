- [device-link](#device-link)
  - [优化设计](#优化设计)
    - [网络协议层和业务层解耦](#网络协议层和业务层解耦)
    - [kafka 生产者优化](#kafka-生产者优化)
    - [业务线程池设计](#业务线程池设计)
    - [平台心跳方案优化](#平台心跳方案优化)
    - [序列化方案优化](#序列化方案优化)
    - [对网络数据通过netty 对象池进行分配](#对网络数据通过netty-对象池进行分配)
  - [功能设计](#功能设计)
  - [功能实现](#功能实现)
### device-link
MQTT网络服务端应用：使用spring boot + Netty实现
#### 优化设计
最开始版本的MQTT服务器将协议处理和平台业务开发放在一个服务器中，导致平台业务升级或者版本迭代时需要对应的进行服务器开发和升级，导致平台已连接设备
会出现服务端断开连接，用户反映很大，每次升级业务困难。另外MQTT 服务器性能也不是很好。
##### 网络协议层和业务层解耦
将身份认证，路由表维护，数据加解密，数据校验，数据路由等业务上移，并为后续新增认证模型，平台设备模型，平台私有数据编解码方案提供了便利支持。
1. 将mqtt 连接认证通过spi的方式调用下游服务；方便了后续的多种认证方式扩展
2. MQTT 报文消息只做协议校验，将报文转化为平台模型通过消息事件通知的方式发送，下游服务消费数据进行业务处理
3. 对下行数据处理，同样的将平台业务上移，MQTT服务器只做数据报文封装和数据发送和事件通知。
4. 规范化平台错误码，平台到设备侧错误码和日志事件错误码
##### kafka 生产者优化
```
batch.size 参数优化：默认16KB，调节到了512KB,增大批量发送报文，结合linger.ms参数使用，设置默认是0，表示不做停留，
调整设置为3,表示3毫秒之后不论batch请求是否达到512KB都会发送出去。既保证了消息的实时也减少了网络的请求。
buffer.memory（吞吐量）：Producer端用于缓存消息的缓冲区大小，单位为字节，默认值为：33554432合计为32M,业务线程较多，共享的是同一个producer，调节到了64M
设置retry.size=0;
ack 设置为1： 表示leader接受到数据即可，0表示发送立即返回，-1：表示ISR完成。

压缩工件：使用了高效的序列化方式
```
##### 业务线程池设计
最开始没有业务线程池，保证同一个socket的消息有序性
```
类比Netty的EventLoopGroup 线程组，设计了BizLoopGroup,
线程组中使用数组管理线程，size固定为2的幂等，当channel连接后，绑定到一个业务线程。保证消息的有序性。
自实现Worker线程，继承Thread,业务线程中提供了一个阻塞队列，用于
```
##### 平台心跳方案优化
```
平台设备路由表是通过mqtt keepalive 字段设置的redis的过期时间，当设备上下线进行路由表维护，平台开始通过为每个socket建一个定时任务，内存用来了jdk的定时线程池，
后续优化将定时任务放到idle check handler中的定时任务中，对该handler进行了改造和重新实现，将每次检测时，如果没有发生idle，则发送alive事件通知下游，进行路由表刷新，
如果出现idle事件，则清理链路，发送下线事件通知。
```
##### 序列化方案优化
```
开始平台统一使用的json序列化方案，使用的fastjson；
后面再MQTT消息事件通知中，使用了protobuf 序列化方式，减少了网络流量，同时序列化方式高效。
上行数据序列化后能提高中间件的效率，下行序列化后能够减少设备网络带宽
```
##### 对网络数据通过netty 对象池进行分配
```
使用直接内存，减少IO数据的复制
内存池，对象池，提高程序性能，减少对象的创建回收，内存的申请和回收。

```

#### 功能设计
``` 
1. 支持MQTT 3.1,3.1.1 tcp和websocket 两种方式接入
2. 支持MQTT connect 报文：通过连接报文进行设备身份认证和老链路剔除，支持明文，签名，加密认证,local session record and ack
3. 支持全局登录路由表维护包括，连接添加，idle check keepAlive refresh续约,断开清理
4. 支持ping消息回复
5. 支持client pub 消息验证路由
6. 支持client pub Qos1消息ack,
7. 支持disconnect 报文 session 清理
8. 支持session 状态机机制，连接报文接受为初始化状态，认证通过为活跃状态，直到服务端断开链路或者主动断开链路后为inactive状态。
9. 定时任务 idle check 120s(同时实现了平台心跳保活机制)，定时check session 中client状态，如果为inactive,则需要进行清理并记录日志。
10. EnableMqttServer 注解，spring boot 项目自动启动。
11. 支持订阅连接和推送连接，订阅连接使用平台订阅服务实现
12. 指标统计（一个周期内）：client 连接数，推送连接数，订阅连接数，数据总量，qos0、1数据量，连接事件数据量，关闭链路数据量
13. 支持优雅关闭服务，关闭连接功能，优雅关闭client
14. 提供对外交互api
15. 支持同一个设备的数据处理顺序和接受顺序一致
16. 支持错误码规范化
17. 支持业务动态开发，服务端不必升级

```
#### 功能实现

1. 支持tcp和websocket 两种方式接入
```
Netty 自支持MQTT的编解码器，工件pipeline即可
```
2. 连接鉴权支持
```
解码MQTT协议，解析CONNECT报文，解析出用户名，clientId,密码；利用spi 方式进行身份认证和全局路由表记录(解耦，方便支持更多的认证)，
认证通过后，记录本地session,触发连接事件，回复connAck。 

auth服务提供认证接口，支持多认证方式，支持订阅和推送连接，支持数据加解密约定

```
3. ping,pub 消息路由
```
ping事件触发，下游处理
pub消息事件触发，下游数据加解密，数据校验，平台规则路由
```
4. 连接断开处理
```
本地session 清理，触发断开连接事件，下游处理，比如清理路由表
```
5. 全局路由表维护和本地无效链路检查清理
```
路由表添加通过auth鉴权添加，老链路剔除，
定时idle check 成功，触发keepAlive事件，下游服务处理刷新路由表
触发下线事件，下游清理路由表
```
6. 服务端优雅关闭
```
监听spring ContextCloseEvent,优雅的关闭关闭服务能力
优雅的处理连接的链路，触发下线行为和事件
```
7. 支持同一个设备的数据处理顺序按照接受顺序
```
设备登录，返回设备唯一标识到session
设备数据处理触发事件，先通过唯一标识hash得到hash值，通过hash值绑定线程，
```