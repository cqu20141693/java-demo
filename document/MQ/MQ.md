- [MQ](#mq)
  - [消息队列选型](#消息队列选型)
  - [消息队列消息丢失](#消息队列消息丢失)
  - [消息重复发送，消费](#消息重复发送消费)
  - [消息乱序](#消息乱序)
  - [消息积压](#消息积压)
  - [延迟队列](#延迟队列)
  - [MQ 积压大量消息?](#mq-积压大量消息)
  - [消息可靠性和一致性保证](#消息可靠性和一致性保证)
    - [副本集](#副本集)
## MQ
[面试题](https://dunwu.github.io/javatech/mq/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E9%9D%A2%E8%AF%95.html)
### 为什么用MQ?MQ带来的问题
为什么用
```
解耦：传统的业务数据流动，需要服务之间进行强编码，比如一个设备数据，刚开始只是做存储，直接调用存储服务，后面需要做数据实时统计，有需要调用统计服务，消息队列，发布者发送事件，各个订阅者自己订阅关心数据处理
异步：多个业务同步调用
```
### 消息队列选型
### 消息队列消息丢失
### 消息重复发送，消费
### 消息乱序
### 消息积压
### 延迟队列
### MQ 积压大量消息?
```
先修复 consumer 的问题，确保其恢复消费速度，然后将现有 consumer 都停掉。
新建一个 topic，partition 是原来的 10 倍，临时建立好原先 10 倍的 queue 数量。
然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的 10 倍数量的 queue。
接着临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据。这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。
等快速消费完积压数据之后，得恢复原先部署的架构，重新用原先的 consumer 机器来消费消息。
```
### 消息可靠性和一致性保证
#### 副本集
