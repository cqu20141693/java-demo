## 算法和数据结构使用
### 时间轮算法
#### 使用场景
1. netty 定时任务
2. pulsar broker定时任务

#### 实现原理
[时间轮算法](https://cloud.tencent.com/developer/article/1815722)
```

```
### LRU 算法
#### 使用场景
缓存淘汰策略： redis 在内存不够时，就会将内存中缓存的key根据最近最少使用进行清理

#### 实现原理
[LRU缓存机制](https://leetcode-cn.com/problems/lru-cache/solution/lruhuan-cun-ji-zhi-by-leetcode-solution/)
```
使用hash表和链表两个数据结构；利用hash能够快速的获取元素，利用链表可以记录元素的访问情况。
1. 首先需要记录元素个数，当空间不够时，需要淘汰链表末尾的元素
2. 元素的访问，更新，新增时都将元素放到链表头

```

### 滑动窗口算法
#### 使用场景

#### 实现原理
```

```

### 雪花算法
#### 使用场景
用于生成递增的分布式id
存在时间回拨问题
#### 实现原理
```
利用64位long型数字存储数据，
最高位用0，使得数据位正整数
后41为时间戳长度，可以用69年
后10位位数据中心和机器为，可以各位5为，用于区分不同的数据中心和应用
后12位用于并发同一秒内最大生成的id,5096
```